<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xloudmax.fun","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="面向对象类（实例）构成 对象（object）对象是类的一个实例  new调用类的构造器var p &#x3D; new Person()  声明  Person p;   实例化  p变量（引用变量）只在栈内存中存储了一个地址值可以有多个指向同一个对象  Person对象存放在堆（heap）内存无指向时被回收    初始化  p &#x3D; new Person();     对象的属性  成员变量（域）field">
<meta property="og:type" content="article">
<meta property="og:title" content="思维导图测试">
<meta property="og:url" content="http://xloudmax.fun/2024/03/13/KEWkzDYOuISyvw4u/KEWkzDYOuISyvw4u/index.html">
<meta property="og:site_name" content="Xloudmax">
<meta property="og:description" content="面向对象类（实例）构成 对象（object）对象是类的一个实例  new调用类的构造器var p &#x3D; new Person()  声明  Person p;   实例化  p变量（引用变量）只在栈内存中存储了一个地址值可以有多个指向同一个对象  Person对象存放在堆（heap）内存无指向时被回收    初始化  p &#x3D; new Person();     对象的属性  成员变量（域）field">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-13T15:00:52.000Z">
<meta property="article:modified_time" content="2024-03-13T15:07:31.711Z">
<meta property="article:author" content="Xloudmax">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xloudmax.fun/2024/03/13/KEWkzDYOuISyvw4u/KEWkzDYOuISyvw4u/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>思维导图测试 | Xloudmax</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <meta charset="UTF-8">
  <title>live2d-demo</title>
  <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
  <!-- Live2DCubismCore -->
  <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/frame/live2dcubismcore.min.js"></script>
  <!-- Include Pixi. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.1/pixi.min.js"></script>
  <!-- Include Cubism Components. -->
  <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismframework.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/live2dcubismpixi.js"></script>
  <!-- User's Script -->
  <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/l2d.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/litstronger/live2d-moc3@master/js/main.js"></script>
  <style>
  </style>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Xloudmax</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Note</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xloudmax.fun/2024/03/13/KEWkzDYOuISyvw4u/KEWkzDYOuISyvw4u/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Xloudmax">
      <meta itemprop="description" content="Welc0me t0 the base">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xloudmax">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          思维导图测试
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-13 23:00:52 / 修改时间：23:07:31" itemprop="dateCreated datePublished" datetime="2024-03-13T23:00:52+08:00">2024-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类（实例）"><a href="#类（实例）" class="headerlink" title="类（实例）"></a>类（实例）</h2><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><ul>
<li><p>对象（object）<br>对象是类的一个实例</p>
<ul>
<li><p>new调用类的构造器<br>var p = new Person()</p>
<ul>
<li><p>声明</p>
<ul>
<li>Person p;</li>
</ul>
</li>
<li><p>实例化</p>
<ul>
<li><p>p变量（引用变量）只在栈内存中存储了一个地址值<br>可以有多个指向同一个对象</p>
</li>
<li><p>Person<br>对象存放在堆<br>（heap）内存<br>无指向时被回收</p>
</li>
</ul>
</li>
<li><p>初始化</p>
<ul>
<li>p = new Person();</li>
</ul>
</li>
</ul>
</li>
<li><p>对象的属性</p>
<ul>
<li><p>成员变量（域）field</p>
<ul>
<li><p>用于定义该类或该类的实例所包含的状态数据<br>[修饰符] 类型 成员变量名 [=默认值]</p>
<ul>
<li><p>实例变量（对象属性） instance 独立</p>
<ul>
<li><p>实例.实例变量<br>类.类变量<br>实例.类变量（不推荐）</p>
</li>
<li><p>setter和getter方法</p>
<ul>
<li><p>setXxx()<br>getXxx()</p>
</li>
<li><p>用于操作对象属性的常见模式，允许访问封装对象的状态并提供对属性的控制和访问</p>
</li>
<li><p>setter和getter方法合起来变成属性，如果只有getter方法，则是只读属性</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>类变量（static）共享</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对象的作用</p>
<ul>
<li><p>封装数据和行为</p>
</li>
<li><p>访问对象的实例变量</p>
</li>
<li><p>调用对象的方法</p>
</li>
</ul>
</li>
<li><p>this关键字</p>
<ul>
<li><p>让类中一个方法，访问该类里的另一个方法或实例变量</p>
</li>
<li><p>所代表的只能是当前<br>类的实例</p>
</li>
<li><p>this作为对象的默认引用</p>
<ul>
<li><p>构造器中引用该构造器正在初始化的对象</p>
</li>
<li><p>方法中引用调用该方法的对象</p>
</li>
</ul>
</li>
<li><p>一个方法访问该类中定义的其他方法、成员变量时，<br>加不加this前缀的效果是完全一样的，this仍然存在</p>
</li>
<li><p>static修饰的方法中不能使用this引用<br>静态成员不能<br>直接访问非静态成员</p>
</li>
<li><p>如果构造器中有一个与成员变量同名的局部变量，又必须在构造器中访问这个被覆盖的成员变量，则必须使用this前缀</p>
</li>
</ul>
</li>
<li><p>实例初始化块</p>
<ul>
<li><p>用于初始化对象的实例成员变量，在构造器执行之前执行</p>
</li>
<li><p>实例初始化块是在创建Java对象时隐式执行的，<br>总是全部执行，因此可以把多个实例初始化块合并成一个实例<br>初始化块，从而可以让程序更加简洁，可读性更强。</p>
</li>
<li><p>如果有一段初始化处理代码对所有对象完全相同，且无须接收<br>任何参数，就可以把这段初始化处理代码提取到实例初始化块中</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><em>对象调用方法<br>方法属于对象</em></p>
</li>
<li><p>方法（method）（形参）<br>类似于函数、但必须包含在类里</p>
<ul>
<li><p>方法的参数传递方式只有一种：值传递。就是将实际参数值的副本（复制品）传入方法内，而参数本身不会受到任何影响。</p>
</li>
<li><p>[修饰符] 方法返回值类型（void） 方法名（形参列表）<br>{<br>可执行性语句组成的方法体<br>}</p>
</li>
<li><p>执行方法</p>
<ul>
<li><p>类调用（static）</p>
</li>
<li><p>对象调用</p>
</li>
</ul>
</li>
<li><p>定义局部变量</p>
<ul>
<li>形参（方法签名中定义）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>方法局部变量（方法内定义）</p>
<p>代码块局部变量（代码块内定义）</p>
<pre><code>        - 局部变量不属于任何类或实例，总是保存在栈内存中，保存基本变量的值和引用变量的地址

        - 局部变量定义后，必须经过显式初始化后才能使用

        - 能用代码块局部变量就不用方法局部变量

            - 扩大了变量的作用域，这不利于提高程序的内聚性。

            - 增大了变量的生存时间，这将导致更大的内存开销。

- 在方法中创建实例 var p = new Person（）
                                   实例化

- 个数可变的形参（只能有一个）

- 递归方法

    - 基准情形

    - 不断推进

        - 向已知基准情形推进

    - 设计法则

        - 假设所有的递归调用都能执行

    - 合成效益法则

        - 求解同一问题时，切勿做重复性的工作

- 方法重载(Overload)

    - 只要形参列表不同 ，可以有多个同名方法

    - 两同一不同

        - 方法名必须相同（&quot;两同&quot;），但参数列表必须不同（&quot;一不同&quot;）

    - 返回值不能区分重载

- toString()方法

    - 返回对象的类名，后跟对象的散列码（hash code）

    - 所有的Java对象都可以和字符串进行连接运算，系统自动调用Java对象
</code></pre><p>toString()方法的返回值和字符串进行连接运算</p>
<pre><code>- equals()方法

    - Object类提供的一个实例方法，经常被重写使用

        -  ➢自反性：对任意x, x.equals(x)一定返回true

        - ➢ 对称性 ： 对任意x和y, 如果y.equals(x)返回 true，则x.equals(y)也返回true

        - ➢ 传 递 性 ： 对任意x,y,z,如果x.equals(y)返回ture,y.equals(z)返回true，则x.equals(z)一定返回true

        - ➢ 一致性：对任意x和y, 如果对象中用于等价比较的信息没有改变, 那么无论调用x.equals(y)多少次，返回的结果应该保持一致，要么一直是true，要么一直是false

        - ➢ 对任何不是null的x, x.equals(null)一定返回false
</code></pre><h3 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h3><ul>
<li><p>类成员<br>（必须通过类来访问、调用）</p>
<ul>
<li><p>类成员（包括成员变量、方法、初始化块、内部类和内部枚举）不能访问<br>实例成员（包括成员变量、方法、初始化块、内部类和内部枚举）</p>
</li>
<li><p>类方法</p>
<ul>
<li>修饰符 static （void）方法名（形参列表）{<br>}<br>public static void test（）{}</li>
</ul>
</li>
<li><p>类变量</p>
<ul>
<li><p>public（修饰符） static 变量名（abcABC)<br>[=默认值]</p>
</li>
<li><p>类变量生存范围几乎等同于该类的生存范围</p>
</li>
<li><p>类变量必须通过类来访问</p>
</li>
</ul>
</li>
<li><p>类初始化块 </p>
<ul>
<li><p>负责对类进行初始化，总是比实例初始化块先执行</p>
</li>
<li><p>执行类初始化块时，系统会按照继承关系逐级上溯（到java.lang.Object类），执行每个父类的类初始化块，然后才执行当前类的类初始化块。</p>
</li>
<li><p>static {可执行性代码}</p>
<ul>
<li>初始化块的修饰符只能是static，使用static修饰的初始化块被<br>称为类初始化块（静态初始化块），没有static修饰的初始化块被称<br>为实例初始化块（非静态初始化块）</li>
</ul>
</li>
</ul>
</li>
<li><p>构造器</p>
<ul>
<li><p>public（修饰符） 构造器名（形参列表）<br>{构造器执行体}（构造器必须与类名相同）</p>
<ul>
<li><p>没有定义构造器，系统将为它提供一个默<br>认的构造器，系统提供的构造器总是没有参数的</p>
</li>
<li><p>通过new关键字来调用构造器，从而返回该类<br>的实例</p>
</li>
<li><p>一旦为一个类提供了构造器，系统将不再为该类提供构造<br>器</p>
</li>
<li><p>返回值是隐式的</p>
</li>
</ul>
</li>
<li><p>构造器是创建对象的重要途径，Java类必须包含一个或一个以上的构造器。</p>
</li>
<li><p>构造器的重载</p>
<ul>
<li>如果一个构造器B完全包含了另一个构造器A，可以使用this关键字来调用构造器A，不会创建新的对象实例。这称为构造器重载，在一个构造器中调用另一个构造器以共享初始化代码。可以避免重复的初始化代码，并确保对象的一致性。</li>
</ul>
</li>
</ul>
</li>
<li><p>内部类</p>
<ul>
<li><p>public class OuterClass<br>{<br>//此处可以定义内部类<br>}</p>
</li>
<li><p>作用</p>
<ul>
<li><p>➢ 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。假设需要创建Cow类，Cow类需要组合一个CowLeg对象，CowLeg类只有在Cow类里才有效，离开了Cow类之后没有任何意义。在这种情况下，就可把CowLeg定义成Cow的内部类，不允许其他类访问CowLeg</p>
</li>
<li><p>➢ 内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员，同一个类的成员之间可以互相访问。但外部类不能访问内部类的实现细节，例如内部类的成员变量</p>
</li>
<li><p>➢ 匿名内部类适合用于创建那些仅需要一次使用的类。对于前面介绍的命令模式，当需要传入一个Command对象时，重新专门定义PrintCommand和SquareCommand两个实现类可能没有太大的意义，因为这两个实现类可能仅需要使用一次。在这种情况下，使用匿名内部类将更方便</p>
</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li><p>➢ 内部类比外部类可以多使用三个修饰符:private 、protected、static.外部类不可以使用这三个修饰符</p>
</li>
<li><p>➢ 非静态内部类不能拥有静态成员</p>
</li>
</ul>
</li>
<li><p>4个作用域：同一个类、同一个包、父子类和任何位置，可以使用任意访问控制符<br>如private、protected和public等修饰</p>
</li>
<li><p>成员内部类</p>
<ul>
<li><p>class文件总是这种形式 ：<br>OuterClass$InnerClass.class</p>
</li>
<li><p>非静态内部类</p>
<ul>
<li><p>可以直接访问外部类的private成<br>员</p>
</li>
<li><p>保存<br>了一个它所寄生的外部类对象的引用（当调用非静态内部类的实例方<br>法时，必须有一个非静态内部类实例，非静态内部类实例必须寄生在<br>外部类实例里）</p>
</li>
<li><p>访问某个变量时，方法内-内部类内-包含内部类的外部类内</p>
</li>
<li><p>如果外部类成员变量、内部类成员变量与内部类里方法的<br>局部变量同名，则可通过使用this、外部类类名.this作为限定来区<br>分</p>
</li>
<li><p>非静态内部类可以访问外部类的实例成员，但外部类无法直接访问非静态内部类的实例成员。如果外部类需要访问非静态内部类的实例成员，必须通过创建内部类的实例来实现</p>
<ul>
<li>当外部类对象被实例化时，非静态内部类的对象并不会自动存在或被创建</li>
</ul>
</li>
<li><p>创建一个非静态内部类的实例，那么它一定会关联到一个外部类对象</p>
<ul>
<li>外部类可以独立存在，而不包含内部类的实例</li>
</ul>
</li>
<li><p>不允许在外部类的静态成员中直接使用非<br>静态内部类</p>
</li>
<li><p>不允许在非静态内部类里定义静态成员</p>
</li>
<li><p>不可以有静态初始化块，但可以包含普通初始<br>化块。非静态内部类普通初始化块的作用与外部类初始化块的作用<br>完全相同</p>
</li>
</ul>
</li>
<li><p>静态内部类（static<br>修饰，类内部类）<br>使用static修饰可以将内部类变成外部类<br>相关，而不是外部类实例相关</p>
<ul>
<li><p>类可以包含静态成员，也可以包含非静态成员</p>
</li>
<li><p>静态内部类不能访问外部类的实<br>例成员，只能访问外部类的类成员</p>
</li>
<li><p>即使是静态内部类的实例方法也<br>不能访问外部类的实例成员，只能访问外部类的静态成员</p>
</li>
<li><p>静态内部类对象只持有外部类的类引用，没有<br>持有外部类对象的引用</p>
</li>
<li><p>允许在接口里定义内部类，接口里定义的内部<br>类默认使用public static修饰，也就是说，接口内部类只能是静态内<br>部类</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用内部类</p>
<ul>
<li><p>在外部类内部使用内部类</p>
<ul>
<li><p>通过 new 关键字调用内部类的构造器来创建实例</p>
</li>
<li><p>不要在外部类的静态成员（包括静态方<br>法和静态初始化块）中使用非静态内部类</p>
</li>
<li><p>可以在外部类内部定义内部类的子类</p>
</li>
</ul>
</li>
<li><p>在外部类以外使用非静态内部类</p>
<ul>
<li><p>访问控制权限</p>
<ul>
<li><p>Private访问控制权限：不允许在外部类以外访问</p>
</li>
<li><p>Public访问控制权限：允许在任何地方访问。</p>
</li>
<li><p>省略访问控制符：只能在与外部类位于同一包中的其他类中访问。</p>
</li>
<li><p>Protected访问控制权限：允许在与外部类位于同一包中的其他类和外部类的子类中访问</p>
</li>
</ul>
</li>
<li><p>内部类的完整类名</p>
<ul>
<li>在外部类以外使用内部类时，内部类的完整类名：OuterClass.InnerClass varName。如果外部类有包名，则还应该增加包名前缀</li>
</ul>
</li>
<li><p>创建非静态内部类的实例</p>
<ul>
<li>在外部类以外创建非静态内部类的实例时，需要使用外部类实例和 new 调用内部类的构造器<br>outerInstance.new InnerConstructor()</li>
</ul>
</li>
<li><p>创建非静态内部类的子类的实例</p>
<ul>
<li>当创建非静态内部类的子类时，子类的构造器需要调用父类内部类的构造器，并且在构造子类的实例时需要确保外部类的实例存在</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li><p>静态成员无法访问非静态内部类，因为非静态内部类依赖于外部类对象的存在，而静态成员不依赖于具体对象的存在</p>
</li>
<li><p>在创建非静态内部类的子类实例时，需要确保父类内部类的构造器可以被调用，这要求外部类对象必须存在</p>
</li>
<li><p>如果有一个非静态内部类的子类对象存在，则一定存在一个对应的外部类对象</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在外部类以外使用静态内部类</p>
<ul>
<li><p>OuterClass.StaticInnerClass obj = new OuterClass.StaticInnerClass();</p>
</li>
<li><p>创建内部类对象时，静态<br>内部类只需使用外部类即可调用构造器，而非静态内部类必须使用外<br>部类对象来调用构造器</p>
</li>
<li><p>相比之下，使用静态内部类比使用非静态内部类要简单很多，<br>只要把外部类当成静态内部类的包空间即可。因此当程序需要使用<br>内部类时，应该优先考虑使用静态内部类</p>
</li>
<li><p>内部类的类名不再是简单地由内<br>部类的类名组成，它实际上还把外部类的类名作为一个命名空间，作<br>为内部类类名的限制。因此子类中的内部类和父类中的内部类不能<br>完全同名，即使二者所包含的内部类的类名相同，但因为它们所处的<br>外部类空间不同，所以它们不可能完全同名，也就不可能重写。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>局部内部类</p>
<ul>
<li><p>作用范围仅限于包含它的方法内部，在方法的外部无法使用它。由于其作用范围的限制，局部内部类不能使用访问控制符或 static 修饰符</p>
</li>
<li><p>作用域限制</p>
<ul>
<li>生命周期仅限于方法的调用和执行过程。</li>
</ul>
</li>
<li><p>局部内部类因其局部性质，在实际开发中很少被使用。由于其作用域限制，无法离开定义它的方法，因此大部分情况下，定义一个类后希望该类能够被多次复用，而局部内部类无法满足这种需求</p>
</li>
<li><p>局部内部类的class文件<br>总是遵循如下命名格式：OuterClass$NInnerClass.class</p>
<ul>
<li><p>N是一个数字，表示不同方法中的局部内部类</p>
</li>
<li><p>同一个类里不可能有两个同名的成员内部类，但在同一个类里可以有两个以上同名的局部内部类（位于不同方法中）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>匿名内部类</p>
<ul>
<li><p>new 实现接口（ ）或 父类构造器（实参列表）<br>{<br>//匿名内部类的类体部分<br>}</p>
<ul>
<li>通常用于一次性的类实例创建<br>但由于其局限性，不适用于需要多次复用的情况</li>
</ul>
</li>
<li><p>匿名内部类必须继承一个父类或实现一个接口，但最多只能继承一个父类或实现一个接口</p>
</li>
<li><p>规则限制</p>
<ul>
<li><p>匿名内部类不能是抽象类，因为它会立即创建匿名内部类的对象</p>
</li>
<li><p>匿名内部类不能定义构造器，但可以使用实例初始化块来完成构造器的功能</p>
</li>
</ul>
</li>
<li><p>实现接口的匿名内部类</p>
<ul>
<li><p>匿名内部类可以实现接口并且可以重写接口中的方法</p>
</li>
<li><p>对于接口的匿名内部类，不能显式定义构造器，只能通过无参构造器创建实例</p>
</li>
</ul>
</li>
<li><p>继承父类的匿名内部类</p>
<ul>
<li><p>匿名内部类可以继承一个父类并重写父类中的方法</p>
</li>
<li><p>对于继承父类的匿名内部类，可以有和父类相似的构造器，根据需要传入参数或不传参数</p>
</li>
</ul>
</li>
<li><p>从Java 8开始，被匿名内部类访问的局部变量可以被隐式视为 final，但不能重新赋值</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>包装类（Wrapper Class）</p>
<ul>
<li><p>Java中一组用于包装基本数据类型的类，这些基本数据类型包括整数、浮点数、字符、布尔值等。包装类的主要作用是将基本数据类型转换为对象</p>
</li>
<li><p>可以直接将基本数据类型赋给包装类<br>必须注意类型匹配，Java会自动进行转换</p>
<ul>
<li><p>自动装箱（Autoboxing）</p>
<ul>
<li>把一个基本类型变量直接赋给对应的包装类变量，或者赋给Object变量（Object是所有类的父类，子类对象可以直接赋给父类变量）</li>
</ul>
</li>
<li><p>自动拆箱（AutoUnboxing）</p>
<ul>
<li><p>允许直接把包装类对象直<br>接赋给一个对应的基本类型变量</p>
</li>
<li><p>比较包装类实例与数值类型的值</p>
<ul>
<li>Integer num = 42;  // 创建一个Integer对象<br>int value = 42;    // 创建一个int值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>if (num == value) {<br>    System.out.println(“相等”);<br>} else {<br>    System.out.println(“不相等”);<br>}</p>
<pre><code>- 实现基本类型变量和字符串之间的转换

    - 利用包装类提供的parseXxx(String s)静态方法
</code></pre><p>（ 除Character之外的所有包装类都提供了该方法）</p>
<pre><code>        - String str = &quot;123&quot;;
</code></pre><p>int num = Integer.parseInt(str);<br>将字符串转换为整数类型</p>
<pre><code>    - 利用包装类提供的valueOf(String s)静态方法

        - String str = &quot;123&quot;;
</code></pre><p>Integer num = Integer.valueOf(str);<br>将字符串转换为 Integer 对象</p>
<pre><code>    - 整数隐式转换为字符串

        - int number = 42;
</code></pre><p>String str = number + “”;  // 将int转换为字符串</p>
<ul>
<li><p>单例类（Singleton）</p>
<ul>
<li><p>一个类始终只能创建一个实例，则这个类被称为单例类</p>
<ul>
<li><p>将类的构造器私有化，以防止外部类创建对象</p>
</li>
<li><p>提供一个public静态方法作为该类的访问点，在这个方法中创建实例对象</p>
<ul>
<li>只能通过 Singleton.getInstance() 方法来获取单例对象</li>
</ul>
</li>
<li><p>使用一个静态变量来缓存已创建的对象，确保每次调用 getInstance() 方法时都返回相同的实例</p>
</li>
<li><p>必须缓存已经创建的对象，否则该类无法知道<br>是否曾经创建过对象，也就无法保证只创建一个对象</p>
<ul>
<li>需要<br>使用一个成员变量来保存曾经创建的对象，因为该成员变量需要被上<br>面的静态方法访问，故该成员变量必须使用static修饰</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>final修饰符</p>
<ul>
<li><p>定义</p>
<ul>
<li><p>既可以修饰成员变量（包括类变量和实例变量），也可以修饰局<br>部变量、形参</p>
<ul>
<li><p>➢ 类变量：必须在静态初始化块中指定初始值或声明该类变量时<br>指定初始值，而且只能在两个地方的其中之一指定</p>
</li>
<li><p>➢ 实例变量：必须在非静态初始化块、声明该实例变量或构造器<br>中指定初始值，而且只能在三个地方的其中之一指定</p>
</li>
</ul>
</li>
<li><p>final修饰的变量不可被改变，一旦获得<br>了初始值，该final变量的值就不能被重新赋值</p>
</li>
<li><p>final修饰的成员变量必须<br>由程序员显式地指定初始值<br>对于final成员变<br>量，程序当然希望总是能访问到它固定的、显式初始化的值</p>
</li>
<li><p>final 成员变量必须在对象构造过程中确保被初始化。如果在构造器、初始化块中对 final 成员变量进行初始化，确保在使用之前初始化，否则会出现默认初始化的情况</p>
</li>
</ul>
</li>
<li><p>final局部变量</p>
<ul>
<li>如果final修饰的局部变量在定义时没有指定默认值，则可以在后<br>面代码中对该final变量赋初始值，但只能一次，不能重复赋值</li>
</ul>
</li>
<li><p>final只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变</p>
</li>
<li><p>可执行“宏替换”的final变量</p>
<ul>
<li>定义一个final变量并在声明时指定一个编译时确定的初始值，编译器在编译时将使用宏变量的地方直接替换为其值，以提高性能和减少代码的复杂性</li>
</ul>
</li>
<li><p>当一个变量满足下面三个条件时，它被认为是一个常量（constant）或直接量（literal）</p>
<ul>
<li><p>➢ 使用final修饰符修饰。</p>
</li>
<li><p>➢ 在定义该final变量时指定了初始值。</p>
</li>
<li><p>➢ 该初始值可以在编译时就被确定下来。</p>
</li>
</ul>
</li>
<li><p>Java会使用常量池来管理曾经用过的字符串直接量，例如执行var a=”java”；语句之后，常量池中就会缓存一个字符串”java”；如果程序再次执行var b=”java”;，系统将会让b直接指向常量池中的”java”字符串，因此a==b将会返回true</p>
</li>
<li><p>final方法</p>
<ul>
<li>final修饰的方法不可被重写</li>
</ul>
</li>
<li><p>final类</p>
<ul>
<li>final修饰的类不可以有子类</li>
</ul>
</li>
</ul>
</li>
<li><p>不可变类</p>
<ul>
<li><p>创建该类的实例后，该实例的实例变量是不可改变的</p>
</li>
<li><p>创建自定义的不可变类</p>
<ul>
<li><p>➢ 使用private和final修饰符来修饰该类的成员变量。</p>
</li>
<li><p>➢ 提供带参数的构造器（或返回该实例的类方法），用于根据传入参数来初始化类里的成员变量。</p>
</li>
<li><p>➢ 仅为该类的成员变量提供getter方法，不要为该类的成员变量提供setter方法，因为普通方法无法修改final修饰的成员变量</p>
</li>
<li><p>如果有必要，重写Object类的hashCode()和equals()方法<br>equals()方法根据<br>关键成员变量来作为两个对象是否相等的标准，除此之外，还<br>应该保证两个用equals()方法判断为相等的对象的hashCode()<br>也相等</p>
</li>
</ul>
</li>
<li><p>缓存实例的不可变类</p>
<ul>
<li><p>缓存实现</p>
<ul>
<li><p>使用valueOf()方法生成对象，系统是否重新生成新对象取决于缓存池中是否已经存在相同对象</p>
</li>
<li><p>private修饰符隐藏构造器，程序只能通过提供的valueOf()方法来获取实例</p>
</li>
</ul>
</li>
<li><p>先进先出（FIFO）规则</p>
<ul>
<li>当缓存池已满时，最先进入缓存的对象会被最先移除，而最后进入缓存的对象会被保留</li>
</ul>
</li>
<li><p>是否隐藏构造器</p>
<ul>
<li><p>需要控制对象创建</p>
</li>
<li><p>需要维护缓存</p>
<ul>
<li>计划在类内部使用缓存来管理对象实例，那么通常需要隐藏构造器，以确保所有对象都经过缓存池的管理</li>
</ul>
</li>
<li><p>控制不可变性</p>
<ul>
<li>隐藏构造器可以确保在对象创建后不再被修改</li>
</ul>
</li>
</ul>
</li>
<li><p>计划在类内部使用缓存来管理对象实例，那么通常需要隐藏构造器，以确保所有对象都经过缓存池的管理</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接口和抽象类</p>
<ul>
<li><p>抽象类</p>
<ul>
<li><p>抽象方法和抽象类必须使用abstract修饰符来定义，有抽象方法<br>的类只能被定义成抽象类，抽象类里可以没有抽象方法</p>
</li>
<li><p>规则“有得有失”</p>
<ul>
<li><p>抽象方法没有方法体</p>
<ul>
<li>public<br>abstract void test()没有一对花括号</li>
</ul>
</li>
<li><p>抽象类不能被实例化，它存在主要是为了被继承。即使抽象类没有抽象方法，也不能创建实例</p>
</li>
<li><p>抽象类可以包含成员变量、方法（普通方法和抽象方法）、构造器、初始化块、内部类（接口、枚举）</p>
</li>
<li><p>抽<br>象类的构造器不能用于创建实例，主要是用于被其子类调用</p>
</li>
<li><p>一个类如果包含抽象方法（直接定义、继承抽象父类但没有实现父类的抽象方法、或者实现接口但没有完全实现接口的抽象方法），那么该类必须声明为抽象类，除非它的子类提供了具体的实现</p>
</li>
</ul>
</li>
<li><p>abstract关键字</p>
<ul>
<li><p>abstract关键字修饰的方法必须被其子类重写才有意义，否则<br>这个方法将永远不会有方法体，因此abstract方法不能定义为<br>private访问权限，即private和abstract不能同时修饰方法</p>
</li>
<li><p>abstract不能用于修饰成员变量，不能用于修饰局部变量，即<br>没有抽象变量、没有抽象成员变量等说法；abstract也不能用于修<br>饰构造器，没有抽象构造器，抽象类里定义的构造器只能是普通构<br>造器</p>
</li>
<li><p>static和abstract并不是绝对互斥的，static和abstract虽然<br>不能同时修饰某个方法，但它们可以同时修饰内部类</p>
</li>
</ul>
</li>
<li><p>模板模式</p>
<ul>
<li>有助于提供通用的框架，同时允许不同的子类提供各自的实现</li>
</ul>
</li>
<li><p>抽象类的作用</p>
<ul>
<li><p>模板模式</p>
<ul>
<li><p>➢ 抽象父类可以只定义需要使用的某些方法，把不能实现的部分抽象成抽象方法，留给其子类去实现。</p>
</li>
<li><p>➢ 父类中可能包含需要调用其他系列方法的方法，这些被调方法既可以由父类实现，也可以由其子类实现。父类里提供的方法只是定义了一个通用算法，其实现也许并不完全由自身实现，而必须依赖于其子类的辅助</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接口</p>
<ul>
<li><p>接口是从多个相似类中抽象出来的规范，接口不提供任何实现。接口体现的是规范和实现分离的设计哲学</p>
</li>
<li><p>一个Java<br>源文件里最多只能有一个public接口，如果一个Java源文件里定义<br>了一个public接口，则该源文件的主文件名必须与该接口名相同</p>
</li>
<li><p>[修饰符] interface 接口名 extends 父接口1， 父接口2…<br>{<br>零个到多个常量定义（只能是静态常量）<br>零个到多个抽象方法定义<br>（只<br>能是抽象实例方法、类方法、默认方法或私有方法）<br>零个到多个内部类、接口、枚举定义<br>零个到多个私有方法、默认方法或类方法定义<br>接口里不能包含构造器和初始<br>化块定义<br>}</p>
<ul>
<li><p>修饰符可以是public或者省略，如果省略了public访问控制<br>符，则默认采用包权限访问控制符，即只有在相同包结构下才<br>可以访问该接口</p>
</li>
<li><p>接口名应与类名采用相同的命名规则</p>
</li>
<li><p>一个接口可以有多个直接父接口，但接口只能继承接口，不能<br>继承类</p>
</li>
<li><p>接口里的常量、方法、内部类和内部枚举都是public访问权限</p>
</li>
</ul>
</li>
<li><p>私有方法</p>
<ul>
<li><p>在接口内部定义私有方法，这些方法只能被接口中的其他默认方法或静态方法所使用，而无法被接口的实现类直接调用</p>
</li>
<li><p>作为工具方法，为接口中的默认方法或类方法提供支持</p>
<ul>
<li>用于在接口内部共享代码逻辑</li>
</ul>
</li>
<li><p>私有<br>方法可以拥有方法体，但私有方法不能使用default修饰。私有方法可<br>以使用static修饰，也就是说，私有方法既可是类方法，也可是实例<br>方法</p>
</li>
</ul>
</li>
<li><p>静态常量</p>
<ul>
<li>在<br>接口中定义成员变量时，不管是否使用public static final修饰符，<br>接口里的成员变量总是使用这三个修饰符来修饰</li>
</ul>
</li>
<li><p>在接口中定义的</p>
<ul>
<li><p>内部类、内部接口、内部枚举，默认都采用public<br>static两个修饰符</p>
</li>
<li><p>方法，只能是抽象方法、类方法、默认方法或私有方<br>法，自动为<br>普通方法增加abstract修饰符</p>
<ul>
<li><p>类方法、默认方法、私有方法都必须有方法实现（方法体）</p>
<ul>
<li>默认方法就是有方法体的实例方法</li>
</ul>
</li>
</ul>
</li>
<li><p>普通方法，接口里的普通方法总是使用public<br>abstract来修饰</p>
<ul>
<li>接口里的普通方法不能有方法实现（方法体）</li>
</ul>
</li>
<li><p>成员变量，不管是否使用public static final修饰符，<br>接口里的成员变量总是使用这三个修饰符来修饰</p>
</li>
</ul>
</li>
<li><p>完全支持多继承</p>
<ul>
<li><p>子接口扩展某个父接口，将<br>会获得父接口里定义的所有抽象方法、常量</p>
</li>
<li><p>子接口可以通过使用 extends 关键字继承多个父接口</p>
</li>
</ul>
</li>
<li><p>使用接口</p>
<ul>
<li><p>主要用途</p>
<ul>
<li><p>➢ 定义变量，也可用于进行强制类型转换。</p>
</li>
<li><p>➢ 调用接口中定义的常量。</p>
</li>
<li><p>➢ 被其他类实现。</p>
</li>
</ul>
</li>
<li><p>类实现接口</p>
<ul>
<li><p>弥补单继承的不足</p>
</li>
<li><p>implements关键字</p>
<ul>
<li>继承使用extends关键字，实现<br>则使用implements关键字</li>
</ul>
</li>
<li><p>public class MyClass extends 父类 implements Interface1, Interface2, Interface3 {<br>// 类的实现<br>}</p>
</li>
<li><p>一个类实现了一个或多个接口之后，这个类必须完全实现这些接<br>口里所定义的全部抽象方法（也就是重写这些抽象方法）；否则，该<br>类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象<br>类</p>
</li>
<li><p>实现接口方法时，必须使用 public 访问修饰符。因为子类（或者实现类）重写父类的方法时，访问权限只能更大或相等，所以实现类实现接口方法时只能使用 public 访问权限</p>
</li>
<li><p>接口不能显式继承任何类，但所有接口类型的引用变量都可以直<br>接赋给Object类型的引用变量</p>
</li>
<li><p>Java 中所有对象最终都是 Object 类的子类。当一个类实现了接口，这个类的实例本质上是 Object 类的子类，因为 Object 类是Java类层级结构的根类</p>
</li>
</ul>
</li>
<li><p>接口内部可以嵌套其他接口。默认情况下，接口内部的接口自动具有 public 和 static 两个修饰符。这表示内部接口默认是静态的，可以直接通过外部接口名访问，并且也是公开可访问的</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接口和抽象类</p>
<ul>
<li><p>接口：作为系统与外界交互的规范，规定了实现者必须向外提供哪些服务（方法），以及调用者可以如何调用这些服务。在程序中使用接口时，它是多个模块间的耦合标准。在多个应用程序之间使用接口时，它是多个程序之间的通信标准。接口类似于整个系统的“总纲”，制定了系统各模块应该遵循的标准。因此，一旦接口被改变，对整个系统或其他系统的影响将是辐射式的，可能导致系统中大部分类都需要修改</p>
</li>
<li><p>抽象类：作为系统中多个子类的共同父类，体现了一种模板式设计。抽象类是系统实现过程中的中间产品，它已经实现了系统的部分功能（那些已提供实现的方法）。然而，这个中间产品依然不能作为最终产品，需要有进一步的完善</p>
</li>
<li><p>相同</p>
<ul>
<li><p>➢ 接口和抽象类都不能被实例化，它们都位于继承树的顶端，用<br>于被其他类实现和继承</p>
</li>
<li><p>➢ 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的<br>普通子类都必须实现这些抽象方法</p>
</li>
</ul>
</li>
<li><p>差别</p>
<ul>
<li><p>➢ 接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法</p>
</li>
<li><p>➢ 接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。</p>
</li>
<li><p>➢ 接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。</p>
</li>
<li><p>➢ 接口里不能包含初始化块；但抽象类则完全可以包含初始化块</p>
</li>
<li><p>➢ 一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="Lambda表达式基本结构"><a href="#Lambda表达式基本结构" class="headerlink" title="Lambda表达式基本结构"></a>Lambda表达式基本结构</h3><ul>
<li><p>形参列表： 允许省略类型，如果只有一个参数可以省略括号</p>
</li>
<li><p>箭头符号 -&gt;：将参数列表与Lambda表达式的主体分隔开</p>
</li>
<li><p>主体： 包含Lambda表达式要执行的语句</p>
</li>
<li><p>如果Lambda表达式只有一个语句，可以省略花括号 {}</p>
</li>
<li><p>如果Lambda表达式只包含一条返回语句，可以省略 return 关键字<br>Lambda表达式需要返回值，而它的代码块中仅有一条<br>省略了return的语句，Lambda表达式会自动返回这条语句的<br>值</p>
</li>
<li><p>Eatable eat = () -&gt; System.out.println(“Eating”);  // 一个没有参数的Lambda表达式<br>eat.eat();</p>
</li>
</ul>
<p>Flyable fly = distance -&gt; System.out.println(“Flying “ + distance + “ miles”);  // 一个带有一个参数的Lambda表达式<br>fly.fly(1000);</p>
<p>Addable add = (a, b) -&gt; a + b;  // 一个带有两个参数的Lambda表达式<br>System.out.println(add.add(5, 3));</p>
<h3 id="Lambda表达式与函数式接口"><a href="#Lambda表达式与函数式接口" class="headerlink" title="Lambda表达式与函数式接口"></a>Lambda表达式与函数式接口</h3><ul>
<li><p>特点</p>
<ul>
<li><p>目标类型：Lambda 表达式的类型，也就是它的目标类型，必须是函数式接口</p>
</li>
<li><p>函数式接口：函数式接口代表只有一个抽象方法的接口。Lambda 表达式实现的是这个唯一的抽象方法</p>
</li>
<li><p>@FunctionalInterface注解：这个注解放在接口定义前，用于告诉编译器该接口必须是函数式接口。如果接口不符合函数式接口的条件，编译器会报错</p>
</li>
</ul>
</li>
<li><p>限制</p>
<ul>
<li><p>➢ Lambda表达式的目标类型必须是明确的函数式接口</p>
</li>
<li><p>➢ Lambda表达式只能为函数式接口创建对象。Lambda表达式只能<br>实现一个方法，因此它只能为只有一个抽象方法的接口（函数<br>式接口）创建对象</p>
</li>
</ul>
</li>
<li><p>确保 Lambda 表达式的目标类型是函数式接口</p>
<ul>
<li>➢ 将Lambda表达式赋值给函数式接口类型的变量<br>Runnable r = () -&gt; System.out.println(“Running…”);</li>
</ul>
</li>
</ul>
<pre><code>- ➢ 将Lambda表达式作为函数式接口类型的参数传给某个方法
</code></pre><p>public void execute(Runnable r) {<br>    r.run();<br>}</p>
<p>execute(() -&gt; System.out.println(“Executing…”));</p>
<pre><code>- ➢ 使用函数式接口对Lambda表达式进行强制类型转换
</code></pre><p>Object obj = (Runnable)() -&gt; System.out.println(“Converting to Runnable…”);</p>
<ul>
<li><p>java.util.function包下预定义了大量函数式接口</p>
<ul>
<li>➢ XxxFunction：这类接口中通常包含一个apply()抽象方法，该<br>方法对参数进行处理、转换（apply()方法的处理逻辑由Lambda<br>表达式来实现），然后返回一个新的值。该函数式接口通常用<br>于对指定数据进行转换处理。<br>➢ XxxConsumer：这类接口中通常包含一个accept()抽象方法，<br>该方法与XxxFunction接口中的apply()方法基本相似，也负责<br>对参数进行处理，只是该方法不会返回处理结果。<br>➢ XxxxPredicate：这类接口中通常包含一个test()抽象方法，<br>该方法通常用来对参数进行某种判断（test()方法的判断逻辑<br>由Lambda表达式来实现），然后返回一个boolean值。该接口通<br>常用于判断参数是否满足特定条件，经常用于进行筛滤数据<br>➢ XxxSupplier：这类接口中通常包含一个getAsXxx()抽象方<br>法 ， 该 方 法 不 需 要 输 入 参数 ，该方法会按某种逻辑算法<br>（getAsXxx ()方法的逻辑算法由Lambda表达式来实现）返回一<br>个数据</li>
</ul>
</li>
</ul>
<h3 id="在Lambda表达式中使用var"><a href="#在Lambda表达式中使用var" class="headerlink" title="在Lambda表达式中使用var"></a>在Lambda表达式中使用var</h3><ul>
<li><p>Predicate<String> myLambda = (String str) -&gt; str.length() &gt; 5;<br>必须明确指定Lambda表达式的目标类型</p>
<ul>
<li>BiFunction<Integer, Integer, Integer> adder = (@Nonnull Integer a, @Nonnull Integer b) -&gt; a + b;<br>不<br>能省略Lambda表达式的形参类型—因为注解只能被放在形参类型之<br>前</li>
</ul>
</li>
</ul>
<h3 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h3><ul>
<li><ul>
<li><p>方法引用的格式为 ClassName::methodName</p>
<ul>
<li><p>引用类方法</p>
<ul>
<li>在Lambda表达式中使用类的静态方法Integer::parseInt</li>
</ul>
</li>
<li><p>引用特定对象的实例方法</p>
<ul>
<li>允许将特定对象的方法作为Lambda表达式的参数传递<br>object::methodName</li>
</ul>
</li>
<li><p>引用某类对象的实例方法</p>
<ul>
<li>Lambda表达式提供的参数是用于调用方法的对象<br>String::substring</li>
</ul>
</li>
</ul>
</li>
<li><p>构造器引用可以用于创建对象，语法是 ClassName::new</p>
</li>
</ul>
</li>
</ul>
<h3 id="与匿名内部类的联系和区别"><a href="#与匿名内部类的联系和区别" class="headerlink" title="与匿名内部类的联系和区别"></a>与匿名内部类的联系和区别</h3><ul>
<li><p>访问变量：两者都可以直接访问外部的局部变量，但这些变量必须是 effectively final(实质上是 final 的，即一旦赋值就不会再被修改)</p>
</li>
<li><p>默认方法：Lambda表达式和匿名内部类都可以直接调用从接口中继承的默认方法</p>
</li>
<li><p>区别</p>
<ul>
<li><p>适用范围</p>
<ul>
<li><p>Lambda表达式只适用于函数式接口，即接口中只包含一个抽象方法的接口</p>
</li>
<li><p>匿名内部类可以为任意接口创建实例，无论接口中有多少个抽象方法</p>
</li>
</ul>
</li>
<li><p>对默认方法的访问</p>
<ul>
<li><p>匿名内部类可以在实现抽象方法的方法体中调用接口中定义的默认方法</p>
</li>
<li><p>Lambda表达式的代码块不允许直接调用接口中的默认方法</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用Lambda表达式调用Arrays的类方法"><a href="#使用Lambda表达式调用Arrays的类方法" class="headerlink" title="使用Lambda表达式调用Arrays的类方法"></a>使用Lambda表达式调用Arrays的类方法</h3><h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul>
<li>对创建对象过程的封装。通过简单工厂，可以将对象的创建逻辑集中管理，提高系统的灵活性</li>
</ul>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ul>
<li><p>使用一个Command接口来定义一个方法，用这个方法来封<br>装“处理行为”</p>
<ul>
<li>public interface Command<br>{<br>//接口里定义的process方法用于封装“处理行为”<br>void process(int element);<br>}</li>
</ul>
</li>
</ul>
<h2 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li><p>目的</p>
<ul>
<li><p>隐藏类的实现细节</p>
</li>
<li><p>通过事先预定的方法来访问数据，在方法里加入控制逻辑，限制对成员变量的不合理访问</p>
</li>
<li><p>可进行数据检查，有利于保证对象信息的完整性</p>
</li>
<li><p>便于修改，提高代码的可维护性</p>
</li>
</ul>
</li>
<li><p>隐藏和封装</p>
<ul>
<li><p>将对象的成员变量和实现细节隐藏起来，不允许外部直接访问</p>
</li>
<li><p>把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作</p>
</li>
</ul>
</li>
<li><ul>
<li><p>private（当前类访问权限）：只能在当前类的内部被访问</p>
</li>
<li><p>default（包访问权限）：不使用任何访问控制符<br>修饰<br>访问控制的成员或外部<br>类可以被相同包下的其他类访问</p>
</li>
<li><p>protected（子类访问权限）：那么这<br>个成员既可以被同一个包中的其他类访问，也可以被不同包中<br>的子类访问，通常是希望其子类来重写这个方法。</p>
</li>
<li><p>public（公共访问权限）：如果一个成员（包括成员变量、方法和构造器等）或者一个外<br>部类使用public访问控制符修饰，那么这个成员或外部类就可<br>以被所有类访问</p>
</li>
</ul>
</li>
<li><p>访问控制符的使用</p>
<ul>
<li><p>类里的绝大部分成员变量都应该使用private修饰，只有一些<br>static修饰的、类似全局变量的成员变量，才可能考虑使用<br>public修饰。</p>
</li>
<li><p>有些方法只用于辅助实现该类的其他<br>方法，这些方法被称为工具方法，工具方法也应该使用private<br>修饰。</p>
</li>
<li><p>如果某个类主要用做其他类的父类，该类里包含的大部分方法<br>可能仅希望被其子类重写，而不想被外界直接调用，则应该使<br>用protected修饰这些方法</p>
</li>
<li><p>希望暴露出来给其他类自由调用的方法应该使用public修饰。</p>
</li>
</ul>
</li>
</ul>
<h3 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h3><ul>
<li><p>相同类型的变量、<br>调用同一个方法时呈现出多种不同的行为特征</p>
</li>
<li><p>引用变量在编译阶段只能调用其编译时类型所具有的方法，但<br>运行时则执行它运行时类型所具有的方法</p>
<ul>
<li>引用变量只能调用声明该变量时所用类里包含的方法。例如，<br>通过Object p=new Person()代码定义一个变量p，则这个p只能调用<br>Object类的方法，而不能调用Person类里定义的方法。</li>
</ul>
</li>
</ul>
<pre><code>- 通过引用变量来访问其包含的实例变量时，系统总是试图访问
</code></pre><p>它编译时类型所定义的成员变量，而不是它运行时类型所定义的成<br>员变量。</p>
<ul>
<li><p>方法重写（override）</p>
<ul>
<li><p>子类中定义一个与父类中已有的方法名称、参数列表和返回类型相同的方法。子类方法的实现将替代父类方法的实现。方法重写必须保持方法签名的一致性，包括方法名称、参数列表和返回类型。</p>
</li>
<li><p>使用 @Override 注解来标记重写方法</p>
</li>
<li><p>动态绑定，指的是在运行时，根据对象的实际类型来确定要调用的方法实现。这允许在父类引用对象的情况下调用子类的方法，实现多态性</p>
</li>
</ul>
</li>
<li><p>向上转型</p>
<ul>
<li>Java允许将子类对象直接赋给父类引用变量，无需任何显式类型转换。这个过程被称为向上转型（Upcasting），向上转型由系统自动完成</li>
</ul>
</li>
<li><p>引用变量的强制类型转换</p>
<ul>
<li><p>类型转换运算符是小括号，类型转换运算符的用 法是：<br>(type)variable，这种用法可以将variable变量转换成一个type类型<br>的变量</p>
</li>
<li><p>类型转换运算符还可以将一个引用类型变量转换<br>成其子类类型</p>
<ul>
<li><p>基本类型之间的转换只能在数值类型之间进行，数值类型和布尔类型<br>之间不能进行类型转换。</p>
</li>
<li><p>引用类型之间的转换只能在具有继承关系的两个类型之间进<br>行，如果是两个没有任何继承关系的类型，则无法进行类型转<br>换，否则编译时就会出现错误。</p>
</li>
<li><p>如果试图把一个父类实例转换<br>成子类类型，则这个对象必须实际上是子类实例才行（即编译<br>时类型为父类类型，而运行时类型是子类类型），否则将在运<br>行时引发ClassCastException异常。</p>
</li>
<li><p>对象 ’instanceof‘ 类型（返回布尔值）<br>instanceof运算符通常用于在进行向下转型之前检查对象的类型，以确保转型是安全的。</p>
<ul>
<li>instanceof运算符前面操<br>作数的编译时类型要么与后面的类相同，要么与后面的类具有父子继<br>承关系</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>类的继承</p>
<ul>
<li><p>每个子类只有一个直接父类</p>
</li>
<li><p>public class 子类名 extends 父类名 {<br>// 子类的成员变量和方法                  }</p>
</li>
<li><p>子类只能从被扩展的父类获得成员变量、方法和内部类（包括<br>内部接口、枚举），不能获得构造器和初始化块。</p>
</li>
<li><p>继承适用于那些具有”is-a”关系的类，即子类是父类的一种特例。</p>
</li>
</ul>
</li>
<li><p>重写父类的方法</p>
<ul>
<li><p>子类包含与父类同名方法的现象被称为方法重写（Override）。</p>
<ul>
<li><p>子类提供了与父类相同名称、参数列表和返回类型的方法，以提供自己的实现。使得子类能够在继承的基础上自定义或修改方法的行为。</p>
</li>
<li><p>“两同两小一大”规则</p>
<ul>
<li><p>方法名相<br>同、形参列表相同</p>
</li>
<li><p>子类方法返回值类型应比父类方<br>法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法<br>声明抛出的异常类更小或相等</p>
</li>
<li><p>子类方法的访问权限<br>应比父类方法的访问权限更大或相等</p>
</li>
</ul>
</li>
<li><p>覆盖方法和被覆盖方法必须具有相同的方法类型，即它们要么都是类方法，要么都是实例方法</p>
</li>
</ul>
</li>
<li><p>当子类覆盖了父类的方法后，子类对象默认无法直接访问父类中被覆盖的方法</p>
<ul>
<li><p>在子类方法内使用 super 关键字（如果被覆盖的方法是实例方法）</p>
<ul>
<li><p>super用于限定该对象调用它从<br>父类继承得到的实例变量或方法</p>
</li>
<li><p>super不能出现在static修饰的方法中。static修饰的<br>方法是属于类的，该方法的调用者可能是一个类，而不是对象</p>
</li>
<li><p>在构造器中使用super，则super用于限定该构造器初始化的<br>是该对象从父类继承得到的实例变量，而不是该类自己定义的实例变<br>量。</p>
</li>
</ul>
</li>
<li><p>使用父类的类名（如果被覆盖的方法是类方法）来调用父类中被覆盖的方法。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>调用父类构造器</p>
<ul>
<li><p>在一个构造器中调用另一个重载的构造器使用this调用来完成</p>
</li>
<li><p>在子类构造器中调用父类构造器使用super调用来完成</p>
</li>
</ul>
</li>
<li><p>继承与组合（类复用）</p>
<ul>
<li><p>父类应有良好的封装性，不会被子类随意改变</p>
<ul>
<li><p>尽量隐藏父类的内部数据</p>
</li>
<li><p>不要让子类可以随意访问、修改父类的方法</p>
</li>
<li><p>尽量不要在父类构造器中调用将要被子类重写的方法</p>
</li>
</ul>
</li>
<li><p>何时需要从父类派生新的子类</p>
<ul>
<li><p>子类需要额外增加成员变量，而不仅仅是变量值的改变。</p>
</li>
<li><p>子类需要增加自己独有的行为方式（包括增加新的方法或重写<br>父类的方法）</p>
</li>
</ul>
</li>
<li><p>利用组合实现复用</p>
<ul>
<li><p>组合是将一个类的对象作为另一个类的成员。这允许新类直接复用现有类的公共方法，而不必继承其全部行为。组合通常适用于那些具有”has-a”关系的类，即一个类包含另一个类的实例作为其一部分。</p>
</li>
<li><p>把旧类对象作为新类的成员变量组合进来，用以实现新类的功能</p>
</li>
<li><p>继承设计与组合设计的<br>系统开销不会有本质的差别</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    
    
    
      <div>
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      </div>
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Xloudmax
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://xloudmax.fun/2024/03/13/KEWkzDYOuISyvw4u/KEWkzDYOuISyvw4u/" title="思维导图测试">http://xloudmax.fun/2024/03/13/KEWkzDYOuISyvw4u/KEWkzDYOuISyvw4u/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JAVA/" rel="tag"># JAVA</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2024/03/14/fpmPrhXnBqw1njOC/fpmPrhXnBqw1njOC/" rel="next" title="顺序表">
      顺序表 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%EF%BC%88%E5%AE%9E%E4%BE%8B%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">类（实例）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E6%88%90"><span class="nav-number">1.1.1.</span> <span class="nav-text">构成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98"><span class="nav-number">1.1.2.</span> <span class="nav-text">成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.2.</span> <span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">Lambda表达式基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.2.</span> <span class="nav-text">Lambda表达式与函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8var"><span class="nav-number">1.2.3.</span> <span class="nav-text">在Lambda表达式中使用var</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-number">1.2.4.</span> <span class="nav-text">方法引用与构造器引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.5.</span> <span class="nav-text">与匿名内部类的联系和区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B0%83%E7%94%A8Arrays%E7%9A%84%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.6.</span> <span class="nav-text">使用Lambda表达式调用Arrays的类方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">面向接口编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">简单工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.2.</span> <span class="nav-text">命令模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-number">1.4.</span> <span class="nav-text">三大特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">1.4.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%EF%BC%88Polymorphism%EF%BC%89"><span class="nav-number">1.4.2.</span> <span class="nav-text">多态（Polymorphism）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.4.3.</span> <span class="nav-text">继承</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xloudmax"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Xloudmax</p>
  <div class="site-description" itemprop="description">Welc0me t0 the base</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xloudmax" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xloudmax" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xloudmax@gmail.com" title="E-Mail → mailto:xloudmax@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Tue Mar 05 2024 08:00:00 GMT+0800 (GMT+08:00) – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xloudmax</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共22k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  















  

  

  


  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/null"},"display":{"position":"right","width":400,"height":800},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
